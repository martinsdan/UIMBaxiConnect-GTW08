substitutions:
  devicename: baxiheatpumpatom
  friendly_name: "Baxi Heat Pump Atom"

esphome:
  name: ${devicename}
  friendly_name: ${friendly_name}
  project:
    name: "Liberdade4.UIMBaxiConnect-GTW08"
    version: "1.2"
  on_boot:
    priority: -100
    then:
      - globals.set:
          id: boot_complete
          value: 'true'
      - logger.log: "Boot complete, select is now active"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Global variable to prevent select actions during boot
globals:
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'

# Wi-Fi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: .iot.liberdade4.com
  fast_connect: true
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret fallback_ap_password

captive_portal:

web_server:
  port: 80

# Home Assistant API
api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

# Logs (baud_rate: 0 frees UART for Modbus)
logger:
  level: INFO
  baud_rate: 0

button:
  - platform: restart
    name: "Restart"

# Integrated status LED on AtomS3
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO35
    num_leds: 1
    chipset: ws2812
    name: "${friendly_name} Status LED"
    id: status_led
    internal: true
    effects:
      - pulse:
          name: "Pulse"
      - strobe:
          name: "Strobe"

# UART configuration for Modbus RS485 via GTW-08
uart:
  id: modbus_uart
  tx_pin: GPIO6
  rx_pin: GPIO5
  baud_rate: 9600
  stop_bits: 1
  parity: NONE

# Modbus RTU
modbus:
  id: modbus1
  uart_id: modbus_uart
  send_wait_time: 250ms

modbus_controller:
  - id: gtw08_controller
    address: 0x64 # GTW-08 default Modbus address (100 decimal = 0x64 hex)
    modbus_id: modbus1
    command_throttle: 500ms
    setup_priority: 100 # Higher priority to ensure reads complete before select evaluates
    update_interval: 15s
    offline_skip_updates: 5 # Skip updates if no response

# ============================================================================
# SENSORS - Read-only values from heat pump via Modbus
# ============================================================================

sensor:
  # Outdoor temperature (Register 384) - Read only, per GTW-08 manual
  # Prioritized first for early polling
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Outdoor Temperature"
    id: outdoor_temp
    address: 384
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
      - skip_initial: 3
      - lambda: |-
          static float last = NAN;
          const float MAX_DELTA = 2.0f;  // max allowed change per 15 s

          if (isnan(last)) {
            last = x;
            return x;  // first reading
          }

          if (fabsf(x - last) > MAX_DELTA) {
            ESP_LOGW("outdoor_temp", "Outlier ignored: last=%.2f new=%.2f", last, x);
            return {};  // drop this sample, HA keeps previous value
          }

          last = x;
          return x;

  # Flow temperature (Register 400 - AM016)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Flow Temperature"
    id: temp_flow
    address: 400
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Return temperature (Register 401 - AM018)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Return Temperature"
    id: temp_return
    address: 401
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Heat pump flow temperature (Register 403 - HM001)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "HP Flow Temperature"
    id: hp_temp_flow
    address: 403
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Heat pump return temperature (Register 404 - HM002)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "HP Return Temperature"
    id: hp_temp_return
    address: 404
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Water pressure (Register 409 - AM019, UINT8 0.1 bar)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Water Pressure"
    id: water_pressure
    address: 409
    register_type: holding
    value_type: U_WORD       # use unsigned 16‑bit, lower byte holds the UINT8
    unit_of_measurement: "bar"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - lambda: |-
          uint16_t raw = (uint16_t)x & 0x00FF;   // take UINT8 from low byte
          if (raw == 0xFF) {
            ESP_LOGD("baxi_pressure", "Water Pressure unavailable sentinel: raw=%u", raw);
            return NAN;
          }
          float v = raw * 0.1f;  // 0.1 bar resolution
          if (v < 0.0f || v > 3.0f) {
            ESP_LOGD("baxi_pressure", "Water Pressure out of range: raw=%u, value=%.2f", raw, v);
            return NAN;
          }
          return v;

  # Error flags (Register 277) - List of errors for all devices
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Error Flags"
    id: error_flags
    address: 277
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic

  # ============================================================================
  # ERROR DETECTION - CORRECTED REGISTERS (per manual section 5.11)
  # ============================================================================
  # Register 531: Generic error indicator (0=no error, 1=at least 1 error)
  # Internal: Use text sensor for readable output instead
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "System Error Indicator"
    id: error_indicator
    address: 531
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 128: Number of control boards connected
  # VISIBLE: Shows how many boards are connected (0-8)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Number of Control Boards"
    id: num_boards
    address: 128
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic

  # ============================================================================
  # BOARD 1 ERROR CODES (Registers 532-533)
  # ============================================================================
  # Register 532: Board 1 Error Code
  # 0xFFFF (65535) = No error on this board
  # 0xFFFE (65534) = Device not available
  # Other values = device-specific error codes
  # Internal: Use text sensor for readable output instead
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 1 Error Code"
    id: board1_error_code
    address: 532
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 533: Board 1 Error Category
  # 0=Locking, 3=Blocking, 6=Warning
  # Internal: Use text sensor for readable output instead
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 1 Error Category"
    id: board1_error_category
    address: 533
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 129: Board 1 Device Type
  # Internal: Use text sensor for readable output instead
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 1 Device Type"
    id: board1_device_type
    address: 129
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # ============================================================================
  # BOARD 2 ERROR CODES (Registers 534-535)
  # ============================================================================
  # Register 534: Board 2 Error Code
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 2 Error Code"
    id: board2_error_code
    address: 534
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 535: Board 2 Error Category
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 2 Error Category"
    id: board2_error_category
    address: 535
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 130: Board 2 Device Type
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 2 Device Type"
    id: board2_device_type
    address: 130
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # ============================================================================
  # BOARD 3 ERROR CODES (Registers 536-537)
  # ============================================================================
  # Register 536: Board 3 Error Code
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 3 Error Code"
    id: board3_error_code
    address: 536
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 537: Board 3 Error Category
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 3 Error Category"
    id: board3_error_category
    address: 537
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # Register 131: Board 3 Device Type
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Board 3 Device Type"
    id: board3_device_type
    address: 131
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic
    internal: true

  # System status (Register 411 - AM012 - Main appliance status)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "System Status Code"
    id: system_status_code
    address: 411
    register_type: holding
    value_type: U_WORD
    internal: true # Hide from Home Assistant

  # Sub status (Register 412 - AM014 - Sub status)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Sub Status Code"
    id: sub_status_code
    address: 412
    register_type: holding
    value_type: U_WORD
    internal: true # Hide from Home Assistant

  # System power output (Register 413 - AM024)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Power Output"
    id: power_output
    address: 413
    register_type: holding
    value_type: U_WORD      # UINT16 0–100
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - lambda: |-
          // Raw 0–100% directly from register
          if (x > 100.0f) {
            ESP_LOGD("baxi_power", "Power Output out of range: raw=%.1f", x);
            // Safety clamp in case of weird values
            return NAN;
          }
          return x;

  # WiFi signal
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  # Uptime
  - platform: uptime
    name: "Uptime"

  # Calculated target temperature based on heating curve
  # Formula: Base + (20 - Outdoor Temp) * Gradient
  - platform: template
    name: "Heating Curve Target"
    id: heating_curve_target
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 15s
    lambda: |-
      float base_temp = id(zone1_curve_base).state;
      float gradient = id(zone1_curve_gradient).state;
      float out_temp = id(outdoor_temp).state;
      // Calculate: Base + (20 - Outdoor) * Gradient
      float target = base_temp + (20.0 - out_temp) * gradient;
      return target;


  # ============================================================================
  # ENERGY MONITORING - Cumulative consumption in kWh
  # ============================================================================

  # Central heating energy (Register 433 - AC005)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Energy - Central Heating"
    id: energy_ch
    address: 433
    register_type: holding
    value_type: U_DWORD  # 32-bit unsigned (kWh total)
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 0

  # Domestic hot water energy (Register 435 - AC006)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Energy - Domestic Hot Water"
    id: energy_dhw
    address: 435
    register_type: holding
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 0

  # Cooling energy (Register 437 - AC007)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Energy - Cooling"
    id: energy_cooling
    address: 437
    register_type: holding
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 0

  # Total energy consumed (Register 439)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Energy - Total"
    id: energy_total
    address: 439
    register_type: holding
    value_type: U_DWORD
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 0

  # Actual power output (Register 460 - AM047, 0.01 kW resolution)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Power - Actual Output"
    id: power_actual
    address: 460
    register_type: holding
    value_type: U_DWORD  # 32-bit in 0.01 kW increments
    unit_of_measurement: "kW"
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01  # Convert 0.01 kW units to kW


# ============================================================================
# TEXT SENSORS - Text status representations
# ============================================================================

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"

  # ============================================================================
  # SYSTEM ERROR STATUS (Register 531 decoded)
  # ============================================================================
  - platform: template
    name: "System Error Status"
    id: error_status_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t error_indicator_val = (uint16_t)id(error_indicator).state;
      if (error_indicator_val == 0) {
        return std::string("No Errors");
      } else {
        return std::string("Error Detected - Check Board Error Codes");
      }

  # ============================================================================
  # BOARD 1 ERROR CODE TEXT (Register 532 decoded)
  # ============================================================================
  - platform: template
    name: "Board 1 Error Code Text"
    id: board1_error_code_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t error_code = (uint16_t)id(board1_error_code).state;
      
      // Special values per manual
      if (error_code == 0xFFFF || error_code == 65535) {
        return std::string("No Error on Board 1");
      }
      if (error_code == 0xFFFE || error_code == 65534) {
        return std::string("Board 1 Device Not Available");
      }
      
      // Return code value for manual lookup
      return std::string("Error Code: 0x" + to_string(error_code) + 
                        " - See manual for device-specific error meaning");

  # ============================================================================
  # BOARD 1 ERROR CATEGORY TEXT (Register 533 decoded)
  # ============================================================================
  - platform: template
    name: "Board 1 Error Category Text"
    id: board1_error_category_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t category = (uint16_t)id(board1_error_category).state;
      switch(category) {
        case 0: return std::string("Locking Error - Device locked, manual intervention needed");
        case 3: return std::string("Blocking Error - Device blocked, operation prevented");
        case 6: return std::string("Warning - Non-critical issue, system can continue");
        default: return std::string("Unknown Error Category: " + to_string(category));
      }

  # ============================================================================
  # BOARD 1 DEVICE TYPE TEXT (Register 129 decoded)
  # ============================================================================
  - platform: template
    name: "Board 1 Device Type Text"
    id: board1_device_type_text
    entity_category: diagnostic
    update_interval: 60s
    lambda: |-
      uint16_t device_type = (uint16_t)id(board1_device_type).state;
      uint8_t category = device_type >> 8;    // Upper byte (ZZ)
      uint8_t number = device_type & 0xFF;    // Lower byte (YY)
      
      std::string device_name;
      switch(category) {
        case 0x00: device_name = "CU-GH"; break;
        case 0x01: device_name = "CU-OH"; break;
        case 0x02: device_name = "EHC"; break;
        case 0x14: device_name = "MK"; break;
        case 0x19: device_name = "SCB"; break;
        case 0x1B: device_name = "EEC"; break;
        case 0x1E: device_name = "Gateway (GTW-08)"; break;
        default: device_name = "Unknown (0x" + to_string(category) + ")"; break;
      }
      
      return std::string(device_name + " - Unit #" + to_string(number));

  # ============================================================================
  # BOARD 2 ERROR CODE TEXT (Register 534 decoded)
  # ============================================================================
  - platform: template
    name: "Board 2 Error Code Text"
    id: board2_error_code_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t error_code = (uint16_t)id(board2_error_code).state;
      
      if (error_code == 0xFFFF || error_code == 65535) {
        return std::string("No Error on Board 2");
      }
      if (error_code == 0xFFFE || error_code == 65534) {
        return std::string("Board 2 Device Not Available");
      }
      
      return std::string("Error Code: 0x" + to_string(error_code) + 
                        " - See manual for device-specific error meaning");

  # ============================================================================
  # BOARD 2 ERROR CATEGORY TEXT (Register 535 decoded)
  # ============================================================================
  - platform: template
    name: "Board 2 Error Category Text"
    id: board2_error_category_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t category = (uint16_t)id(board2_error_category).state;
      switch(category) {
        case 0: return std::string("Locking Error - Device locked, manual intervention needed");
        case 3: return std::string("Blocking Error - Device blocked, operation prevented");
        case 6: return std::string("Warning - Non-critical issue, system can continue");
        default: return std::string("Unknown Error Category: " + to_string(category));
      }

  # ============================================================================
  # BOARD 2 DEVICE TYPE TEXT (Register 130 decoded)
  # ============================================================================
  - platform: template
    name: "Board 2 Device Type Text"
    id: board2_device_type_text
    entity_category: diagnostic
    update_interval: 60s
    lambda: |-
      uint16_t device_type = (uint16_t)id(board2_device_type).state;
      uint8_t category = device_type >> 8;
      uint8_t number = device_type & 0xFF;
      
      std::string device_name;
      switch(category) {
        case 0x00: device_name = "CU-GH"; break;
        case 0x01: device_name = "CU-OH"; break;
        case 0x02: device_name = "EHC"; break;
        case 0x14: device_name = "MK"; break;
        case 0x19: device_name = "SCB"; break;
        case 0x1B: device_name = "EEC"; break;
        case 0x1E: device_name = "Gateway (GTW-08)"; break;
        default: device_name = "Unknown (0x" + to_string(category) + ")"; break;
      }
      
      return std::string(device_name + " - Unit #" + to_string(number));

  # ============================================================================
  # BOARD 3 ERROR CODE TEXT (Register 536 decoded)
  # ============================================================================
  - platform: template
    name: "Board 3 Error Code Text"
    id: board3_error_code_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t error_code = (uint16_t)id(board3_error_code).state;
      
      if (error_code == 0xFFFF || error_code == 65535) {
        return std::string("No Error on Board 3");
      }
      if (error_code == 0xFFFE || error_code == 65534) {
        return std::string("Board 3 Device Not Available");
      }
      
      return std::string("Error Code: 0x" + to_string(error_code) + 
                        " - See manual for device-specific error meaning");

  # ============================================================================
  # BOARD 3 ERROR CATEGORY TEXT (Register 537 decoded)
  # ============================================================================
  - platform: template
    name: "Board 3 Error Category Text"
    id: board3_error_category_text
    entity_category: diagnostic
    update_interval: 30s
    lambda: |-
      uint16_t category = (uint16_t)id(board3_error_category).state;
      switch(category) {
        case 0: return std::string("Locking Error - Device locked, manual intervention needed");
        case 3: return std::string("Blocking Error - Device blocked, operation prevented");
        case 6: return std::string("Warning - Non-critical issue, system can continue");
        default: return std::string("Unknown Error Category: " + to_string(category));
      }

  # ============================================================================
  # BOARD 3 DEVICE TYPE TEXT (Register 131 decoded)
  # ============================================================================
  - platform: template
    name: "Board 3 Device Type Text"
    id: board3_device_type_text
    entity_category: diagnostic
    update_interval: 60s
    lambda: |-
      uint16_t device_type = (uint16_t)id(board3_device_type).state;
      uint8_t category = device_type >> 8;
      uint8_t number = device_type & 0xFF;
      
      std::string device_name;
      switch(category) {
        case 0x00: device_name = "CU-GH"; break;
        case 0x01: device_name = "CU-OH"; break;
        case 0x02: device_name = "EHC"; break;
        case 0x14: device_name = "MK"; break;
        case 0x19: device_name = "SCB"; break;
        case 0x1B: device_name = "EEC"; break;
        case 0x1E: device_name = "Gateway (GTW-08)"; break;
        default: device_name = "Unknown (0x" + to_string(category) + ")"; break;
      }
      
      return std::string(device_name + " - Unit #" + to_string(number));

  # System Status (Register 411)
  - platform: template
    name: "System Status"
    id: system_status_text
    entity_category: diagnostic
    update_interval: 15s
    lambda: |-
      uint16_t status_code = (uint16_t)id(system_status_code).state;
      switch(status_code) {
        case 0: return std::string("Standby");
        case 1: return std::string("Heat Demand");
        case 2: return std::string("Generator start");
        case 3: return std::string("Generator CH");
        case 4: return std::string("Generator DHW");
        case 5: return std::string("Generator stop");
        case 6: return std::string("Pump Post Run");
        case 7: return std::string("Cooling Active");
        case 8: return std::string("Controlled Stop");
        case 9: return std::string("Blocking Mode");
        case 10: return std::string("Locking Mode");
        case 11: return std::string("Load test min");
        case 12: return std::string("Load test CH max");
        case 13: return std::string("Load test DHW max");
        case 15: return std::string("Manual Heat Demand");
        case 16: return std::string("Frost Protection");
        case 17: return std::string("Deaeration");
        case 18: return std::string("Control unit Cooling");
        case 19: return std::string("Reset In Progress");
        case 20: return std::string("Auto Filling");
        case 21: return std::string("Halted");
        case 22: return std::string("Forced calibration");
        case 23: return std::string("Factory test");
        case 24: return std::string("Hydronic balancing");
        case 200: return std::string("Device Mode");
        case 254: return std::string("Unknown");
        default: return std::string("Unknown (" + to_string(status_code) + ")");
      }

  # Sub Status (Register 412) - Friendly Name (Tab.17 AM014)
  - platform: template
    name: "Sub Status"
    id: sub_status_text
    entity_category: diagnostic
    update_interval: 15s
    lambda: |-
      uint16_t sub_code = (uint16_t)id(sub_status_code).state;
      switch(sub_code) {
        case 0: return std::string("Standby");
        case 1: return std::string("AntiCycling");
        case 2: return std::string("CloseHydraulicValve");
        case 3: return std::string("ClosePump");
        case 4: return std::string("WaitingForStartCond");
        case 10: return std::string("CloseExtGasValve");
        case 11: return std::string("StartToGlueGasValve");
        case 12: return std::string("CloseFlueGasValve");
        case 13: return std::string("FanToPrePurge");
        case 14: return std::string("WaitForReleaseSignal");
        case 15: return std::string("BurnerOnCommandToSu");
        case 16: return std::string("VpsTest");
        case 17: return std::string("PreIgnition");
        case 18: return std::string("Ignition");
        case 19: return std::string("FlameCheck");
        case 20: return std::string("Interpurge");
        case 21: return std::string("Generator starting");
        case 30: return std::string("Normal Int.Setpoint");
        case 31: return std::string("Limited Int.Setpoint");
        case 32: return std::string("NormalPowerControl");
        case 33: return std::string("GradLevel1PowerCtrl");
        case 34: return std::string("GradLevel2PowerCtrl");
        case 35: return std::string("GradLevel3PowerCtrl");
        case 36: return std::string("ProtectFlamePwrCtrl");
        case 37: return std::string("StabilizationTime");
        case 38: return std::string("ColdStart");
        case 39: return std::string("ChResume");
        case 40: return std::string("SuRemoveBurner");
        case 41: return std::string("FanToPostPurge");
        case 42: return std::string("OpenExtFlueGasValve");
        case 43: return std::string("StopFanToFlueGVRpm");
        case 44: return std::string("StopFan");
        case 45: return std::string("LimitedPwrOnTflueGas");
        case 46: return std::string("AutoFillingInstall");
        case 47: return std::string("AutoFillingTopUp");
        case 48: return std::string("Reduced Set Point");
        case 49: return std::string("Offset adaption");
        case 60: return std::string("PumpPostRunning");
        case 61: return std::string("OpenPump");
        case 62: return std::string("OpenHydraulicValve");
        case 63: return std::string("Start anticycle time");
        case 65: return std::string("Compressor relieved");
        case 66: return std::string("HP Tmax backup on");
        case 67: return std::string("Outdoor limit HP off");
        case 68: return std::string("HP stop by hybrid");
        case 69: return std::string("Defrost with HP");
        case 70: return std::string("Defrost with backup");
        case 71: return std::string("Defrost HP backup");
        case 72: return std::string("Source pump backup");
        case 73: return std::string("HP flow over Tmax");
        case 74: return std::string("Source pump post run");
        case 75: return std::string("HP off high humidity");
        case 76: return std::string("HP off water flow");
        case 78: return std::string("Humidity setpoint");
        case 79: return std::string("Generators relieved");
        case 80: return std::string("HP relieved cooling");
        case 81: return std::string("HP stop outdoor temp");
        case 82: return std::string("HP off flow Tmax");
        case 83: return std::string("Deair pump valve CH");
        case 84: return std::string("Deair pump valve DHW");
        case 85: return std::string("Deair valve CH");
        case 86: return std::string("Deair valve DHW");
        case 88: return std::string("BL backup off");
        case 89: return std::string("BL HP off");
        case 90: return std::string("BL HP backup off");
        case 91: return std::string("Low tariff");
        case 92: return std::string("PV with HP");
        case 93: return std::string("PV HP and backup");
        case 94: return std::string("Smart Grid SG");
        case 95: return std::string("WaitingForWaterpress");
        case 96: return std::string("NoProducerAvailable");
        case 97: return std::string("Increased min power");
        case 98: return std::string("Decreased max power");
        case 102: return std::string("Free cool pump off");
        case 103: return std::string("Free cool pump on");
        case 104: return std::string("Source pump pre run");
        case 105: return std::string("Calibration");
        case 106: return std::string("Blocking active");
        case 107: return std::string("Warm up");
        case 108: return std::string("Defrost curative");
        case 109: return std::string("Defrost preventive");
        case 200: return std::string("Initialising Done");
        case 201: return std::string("Initialising Csu");
        case 202: return std::string("Init identifiers");
        case 203: return std::string("Init.BL.Parameter");
        case 204: return std::string("Init safety unit");
        case 205: return std::string("Init blocking");
        case 254: return std::string("StateUnknown");
        case 255: return std::string("SuOutOfResetsWait1Hr");
        default: return std::string("Unknown (" + to_string(sub_code) + ")");
      }

# ============================================================================
# BINARY SENSORS - Button input
# ============================================================================

binary_sensor:
  # Integrated button
  - platform: gpio
    pin:
      number: GPIO41
      inverted: true
    name: "Button"
    on_press:
      then:
        - light.toggle: status_led

# ============================================================================
# SELECTS - Read-write control options
# ============================================================================

select:
  # Algorithm Type (Register 258) - Remote management mode per Tab.19
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Algorithm Type"
    id: algorithm_type_select
    address: 258
    value_type: U_WORD
    entity_category: config
    optionsmap:
      "Both Temp & Power": 0
      "Power Only": 1
      "Temperature Only": 2
      "Monitoring Only": 3

  # Heat Demand control (Register 259) - Valid options per Tab.20: 0=Standby, 7=Heating, 8=Cooling
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Heat Demand"
    id: heat_demand_select
    address: 259
    value_type: U_WORD
    entity_category: config
    optionsmap:
      "Standby": 0
      "Heating": 7
      "Cooling": 8
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(boot_complete);'
            then:
              - if:
                  condition:
                    lambda: 'return x == "Heating";'
                  then:
                    - light.turn_on:
                        id: status_led
                        brightness: 100%
                        red: 0%
                        green: 0%
                        blue: 100%
              - if:
                  condition:
                    lambda: 'return x == "Cooling";'
                  then:
                    - light.turn_on:
                        id: status_led
                        brightness: 100%
                        red: 0%
                        green: 100%
                        blue: 100%
              - if:
                  condition:
                    lambda: 'return x == "Standby";'
                  then:
                    - light.turn_on:
                        id: status_led
                        brightness: 30%
                        red: 100%
                        green: 50%
                        blue: 0%

  # Zone 1 Operating Mode (Register 649 - CP215)
  # Controls whether zone uses scheduling (heating curve) or manual mode
  # 0 = Scheduling (uses curve from registers 674/675)
  # 1 = Manual (fixed setpoint, ignores curve)
  # 2 = Off
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Zone 1 Operating Mode"
    id: zone1_operating_mode_select
    address: 649
    value_type: U_WORD
    entity_category: config
    optionsmap:
      "Scheduling (uses heating curve)": 0
      "Manual (fixed setpoint)": 1
      "Off": 2

# ============================================================================
# NUMBER CONTROLS - Read-write numeric values
# ============================================================================
number:

  # Zone 1 Heating Curve Configuration (Registers 675 & 674)
  # These registers control the intelligent heating curve for Zone 1
  # Base temperature is the target flow at 20°C outdoor
  # Gradient is the temperature increase per °C of outdoor temperature drop

  # Base Temperature Setpoint (Register 675 - CP210)
  # Display: 15.0-30.0°C, Lambda: divides by 10 for read, multiplies by 10 for write
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Zone 1 Heating Curve Base"
    id: zone1_curve_base
    address: 675
    register_type: holding
    value_type: U_WORD
    step: 0.1
    unit_of_measurement: "°C"
    entity_category: config
    lambda: |-
      return x * 0.1;
    write_lambda: |-
      return x * 10;


  # Heating Curve Gradient (Register 674 - CP230)
  # Display: 0.3-2.0, Lambda: divides by 10 for read, multiplies by 10 for write
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Zone 1 Heating Curve Gradient"
    id: zone1_curve_gradient
    address: 674
    register_type: holding
    value_type: U_WORD
    step: 0.1
    entity_category: config
    lambda: |-
      return x * 0.1;
    write_lambda: |-
      return x * 10;
