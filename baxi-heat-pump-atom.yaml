substitutions:
  devicename: baxiheatpumpatom
  friendly_name: "Baxi Heat Pump Atom"

esphome:
  name: ${devicename}
  friendly_name: ${friendly_name}
  project:
    name: "Liberdade4.UIMBaxiConnect-GTW08"
    version: "1.2"
  on_boot:
    priority: -100
    then:
      - globals.set:
          id: boot_complete
          value: 'true'
      - logger.log: "Boot complete, select is now active"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Global variable to prevent select actions during boot
globals:
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'

# Wi-Fi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: .iot.liberdade4.com
  fast_connect: true
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret fallback_ap_password

captive_portal:

web_server:
  port: 80

# Home Assistant API
api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

# Logs (baud_rate: 0 frees UART for Modbus)
logger:
  level: INFO
  baud_rate: 0

button:
  - platform: restart
    name: "Restart"

# Integrated status LED on AtomS3
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO35
    num_leds: 1
    chipset: ws2812
    name: "${friendly_name} Status LED"
    id: status_led
    internal: true
    effects:
      - pulse:
          name: "Pulse"
      - strobe:
          name: "Strobe"

# UART configuration for Modbus RS485 via GTW-08
uart:
  id: modbus_uart
  tx_pin: GPIO6
  rx_pin: GPIO5
  baud_rate: 9600
  stop_bits: 1
  parity: NONE

# Modbus RTU
modbus:
  id: modbus1
  uart_id: modbus_uart
  send_wait_time: 250ms

modbus_controller:
  - id: gtw08_controller
    address: 0x64 # GTW-08 default Modbus address (100 decimal = 0x64 hex)
    modbus_id: modbus1
    command_throttle: 200ms
    setup_priority: 100 # Higher priority to ensure reads complete before select evaluates
    update_interval: 15s
    offline_skip_updates: 5 # Skip updates if no response

# ============================================================================
# SENSORS - Read-only values from heat pump via Modbus
# ============================================================================
sensor:
  # Outdoor temperature (Register 384) - Read only, per GTW-08 manual
  # Prioritized first for early polling
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Outdoor Temperature"
    id: outdoor_temp
    address: 384
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Flow temperature (Register 400 - AM016)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Flow Temperature"
    id: temp_flow
    address: 400
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Return temperature (Register 401 - AM018)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Return Temperature"
    id: temp_return
    address: 401
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Heat pump flow temperature (Register 403 - HM001)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "HP Flow Temperature"
    id: hp_temp_flow
    address: 403
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Heat pump return temperature (Register 404 - HM002)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "HP Return Temperature"
    id: hp_temp_return
    address: 404
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # DHW Flow setpoint (Register 408 - DM004)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "DHW Setpoint"
    id: dhw_setpoint_read
    address: 408
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Water pressure (Register 409 - AM019)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Water Pressure"
    id: water_pressure
    address: 409
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "bar"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # Error code (Register 410 - for diagnostics)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Error Code"
    id: error_code
    address: 410
    register_type: holding
    value_type: U_WORD
    entity_category: diagnostic

  # System status (Register 411 - AM012 - Main appliance status)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "System Status Code"
    id: system_status_code
    address: 411
    register_type: holding
    value_type: U_WORD
    internal: true # Hide from Home Assistant

  # Sub status (Register 412 - AM014 - Sub status)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Sub Status Code"
    id: sub_status_code
    address: 412
    register_type: holding
    value_type: U_WORD
    internal: true # Hide from Home Assistant

  # System power output (Register 413 - AM024)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Power Output"
    id: power_output
    address: 413
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0

  # WiFi signal
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  # Uptime
  - platform: uptime
    name: "Uptime"

  # Calculated target temperature based on heating curve
  # Formula: Base + (20 - Outdoor Temp) * Gradient
  # This shows what the heat pump should be targeting
  - platform: template
    name: "Heating Curve Target"
    id: heating_curve_target
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 15s
    lambda: |-
      float base_temp = id(zone1_curve_base).state;
      float gradient = id(zone1_curve_gradient).state;
      float out_temp = id(outdoor_temp).state;
      
      // Calculate: Base + (20 - Outdoor) * Gradient
      float target = base_temp + (20.0 - out_temp) * gradient;
      return target;

# ============================================================================
# TEXT SENSORS - Text status representations
# ============================================================================
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"

  # System Status (Register 411) - Friendly Name (Tab.16 AM012)
  - platform: template
    name: "System Status"
    id: system_status_text
    entity_category: diagnostic
    update_interval: 15s
    lambda: |-
      uint16_t status_code = (uint16_t)id(system_status_code).state;
      switch(status_code) {
        case 0: return std::string("Standby");
        case 1: return std::string("Heat Demand");
        case 2: return std::string("Generator start");
        case 3: return std::string("Generator CH");
        case 4: return std::string("Generator DHW");
        case 5: return std::string("Generator stop");
        case 6: return std::string("Pump Post Run");
        case 7: return std::string("Cooling Active");
        case 8: return std::string("Controlled Stop");
        case 9: return std::string("Blocking Mode");
        case 10: return std::string("Locking Mode");
        case 11: return std::string("Load test min");
        case 12: return std::string("Load test CH max");
        case 13: return std::string("Load test DHW max");
        case 15: return std::string("Manual Heat Demand");
        case 16: return std::string("Frost Protection");
        case 17: return std::string("Deaeration");
        case 18: return std::string("Control unit Cooling");
        case 19: return std::string("Reset In Progress");
        case 20: return std::string("Auto Filling");
        case 21: return std::string("Halted");
        case 22: return std::string("Forced calibration");
        case 23: return std::string("Factory test");
        case 24: return std::string("Hydronic balancing");
        case 200: return std::string("Device Mode");
        case 254: return std::string("Unknown");
        default: return std::string("Unknown (" + to_string(status_code) + ")");
      }

  # Sub Status (Register 412) - Friendly Name (Tab.17 AM014)
  - platform: template
    name: "Sub Status"
    id: sub_status_text
    entity_category: diagnostic
    update_interval: 15s
    lambda: |-
      uint16_t sub_code = (uint16_t)id(sub_status_code).state;
      switch(sub_code) {
        case 0: return std::string("Standby");
        case 1: return std::string("AntiCycling");
        case 2: return std::string("CloseHydraulicValve");
        case 3: return std::string("ClosePump");
        case 4: return std::string("WaitingForStartCond");
        case 10: return std::string("CloseExtGasValve");
        case 11: return std::string("StartToGlueGasValve");
        case 12: return std::string("CloseFlueGasValve");
        case 13: return std::string("FanToPrePurge");
        case 14: return std::string("WaitForReleaseSignal");
        case 15: return std::string("BurnerOnCommandToSu");
        case 16: return std::string("VpsTest");
        case 17: return std::string("PreIgnition");
        case 18: return std::string("Ignition");
        case 19: return std::string("FlameCheck");
        case 20: return std::string("Interpurge");
        case 21: return std::string("Generator starting");
        case 30: return std::string("Normal Int.Setpoint");
        case 31: return std::string("Limited Int.Setpoint");
        case 32: return std::string("NormalPowerControl");
        case 33: return std::string("GradLevel1PowerCtrl");
        case 34: return std::string("GradLevel2PowerCtrl");
        case 35: return std::string("GradLevel3PowerCtrl");
        case 36: return std::string("ProtectFlamePwrCtrl");
        case 37: return std::string("StabilizationTime");
        case 38: return std::string("ColdStart");
        case 39: return std::string("ChResume");
        case 40: return std::string("SuRemoveBurner");
        case 41: return std::string("FanToPostPurge");
        case 42: return std::string("OpenExtFlueGasValve");
        case 43: return std::string("StopFanToFlueGVRpm");
        case 44: return std::string("StopFan");
        case 45: return std::string("LimitedPwrOnTflueGas");
        case 46: return std::string("AutoFillingInstall");
        case 47: return std::string("AutoFillingTopUp");
        case 48: return std::string("Reduced Set Point");
        case 49: return std::string("Offset adaption");
        case 60: return std::string("PumpPostRunning");
        case 61: return std::string("OpenPump");
        case 62: return std::string("OpenHydraulicValve");
        case 63: return std::string("Start anticycle time");
        case 65: return std::string("Compressor relieved");
        case 66: return std::string("HP Tmax backup on");
        case 67: return std::string("Outdoor limit HP off");
        case 68: return std::string("HP stop by hybrid");
        case 69: return std::string("Defrost with HP");
        case 70: return std::string("Defrost with backup");
        case 71: return std::string("Defrost HP backup");
        case 72: return std::string("Source pump backup");
        case 73: return std::string("HP flow over Tmax");
        case 74: return std::string("Source pump post run");
        case 75: return std::string("HP off high humidity");
        case 76: return std::string("HP off water flow");
        case 78: return std::string("Humidity setpoint");
        case 79: return std::string("Generators relieved");
        case 80: return std::string("HP relieved cooling");
        case 81: return std::string("HP stop outdoor temp");
        case 82: return std::string("HP off flow Tmax");
        case 83: return std::string("Deair pump valve CH");
        case 84: return std::string("Deair pump valve DHW");
        default: return std::string("Unknown (" + to_string(sub_code) + ")");
      }

# ============================================================================
# BINARY SENSORS - Button input
# ============================================================================
binary_sensor:
  # Integrated button
  - platform: gpio
    pin:
      number: GPIO41
      inverted: true
    name: "Button"
    on_press:
      then:
        - light.toggle: status_led

# ============================================================================
# SELECTS - Read-write control options
# ============================================================================
select:
  # Algorithm Type (Register 258) - Remote management mode per Tab.19
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Algorithm Type"
    id: algorithm_type_select
    address: 258
    value_type: U_WORD
    entity_category: config
    optionsmap:
      "Both Temp & Power": 0
      "Power Only": 1
      "Temperature Only": 2
      "Monitoring Only": 3

  # Heat Demand control (Register 259) - Valid options per Tab.20: 0=Standby, 7=Heating, 8=Cooling
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Heat Demand"
    id: heat_demand_select
    address: 259
    value_type: U_WORD
    entity_category: config
    optionsmap:
      "Standby": 0
      "Heating": 7
      "Cooling": 8
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(boot_complete);'
            then:
              - if:
                  condition:
                    lambda: 'return x == "Heating";'
                  then:
                    - light.turn_on:
                        id: status_led
                        brightness: 100%
                        red: 0%
                        green: 0%
                        blue: 100%
              - if:
                  condition:
                    lambda: 'return x == "Cooling";'
                  then:
                    - light.turn_on:
                        id: status_led
                        brightness: 100%
                        red: 0%
                        green: 100%
                        blue: 100%
              - if:
                  condition:
                    lambda: 'return x == "Standby";'
                  then:
                    - light.turn_on:
                        id: status_led
                        brightness: 30%
                        red: 100%
                        green: 50%
                        blue: 0%

# ============================================================================
# NUMBER CONTROLS - Read-write numeric values
# ============================================================================
number:
  # DHW temperature setpoint (Register 408)
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "DHW Temperature Setpoint"
    address: 408
    register_type: holding
    value_type: U_WORD
    min_value: 30
    max_value: 60
    step: 1
    unit_of_measurement: "°C"
    entity_category: config

  # Zone 1 Heating Curve Configuration (Registers 675 & 674)
  # These registers control the intelligent heating curve for Zone 1
  # Base temperature is the target flow at 20°C outdoor
  # Gradient is the temperature increase per °C of outdoor temperature drop

  # Base Temperature Setpoint (Register 675 - CP210)
  # Display: 15.0-30.0°C, Lambda: divides by 10 for read, multiplies by 10 for write
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Zone 1 Heating Curve Base"
    id: zone1_curve_base
    address: 675
    register_type: holding
    value_type: U_WORD
    min_value: 15.0
    max_value: 30.0
    step: 0.1
    unit_of_measurement: "°C"
    entity_category: config
    lambda: |-
      return x * 0.1;
    write_lambda: |-
      uint16_t base_temp = (uint16_t)(x * 10);
      payload.push_back(base_temp);
      return base_temp;

  # Heating Curve Gradient (Register 674 - CP230)
  # Display: 0.3-2.0, Lambda: divides by 10 for read, multiplies by 10 for write
  - platform: modbus_controller
    modbus_controller_id: gtw08_controller
    name: "Zone 1 Heating Curve Gradient"
    id: zone1_curve_gradient
    address: 674
    register_type: holding
    value_type: U_WORD
    min_value: 0.3
    max_value: 2.0
    step: 0.1
    entity_category: config
    lambda: |-
      return x * 0.1;
    write_lambda: |-
      uint16_t gradient = (uint16_t)(x * 10);
      payload.push_back(gradient);
      return gradient;
